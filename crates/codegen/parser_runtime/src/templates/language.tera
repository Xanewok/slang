#[cfg(feature = "slang_napi_interfaces")]
use { napi::bindgen_prelude::*, napi_derive::napi };

use semver::Version;

use super::{
    cst,
    kinds::{RuleKind, TokenKind, ProductionKind},
    parse_output::ParseOutput,
    support::*,
};

#[cfg( feature = "slang_napi_interfaces" )]
use super::napi::napi_parse_output::ParseOutput as NAPIParseOutput;

#[derive(Debug)]
#[cfg_attr( feature = "slang_napi_interfaces", napi(namespace = "language") )]
pub struct Language {
    pub(crate) version: Version,
    {%- for version in code.referenced_versions -%}
        pub(crate) version_is_at_least_{{ version | replace(from=".", to="_") }}: bool,
    {%- endfor -%}
}

#[derive(thiserror::Error, Debug)]
pub enum Error {
    #[error("Unsupported {{ language_name }} language version '{0}'.")]
    UnsupportedLanguageVersion(Version),

    #[cfg( feature = "slang_napi_interfaces" )]
    #[error("Invalid semantic version '{0}'.")]
    InvalidSemanticVersion(String),
}

#[cfg( feature = "slang_napi_interfaces" )]
impl From<Error> for napi::Error {
    fn from(value: Error) -> Self {
        napi::Error::from_reason(value.to_string())
    }
}

impl Language {
    pub const SUPPORTED_VERSIONS: &[Version] = &[
        {%- for version in versions -%}
            Version::new({{ version | split(pat=".") | join(sep=", ") }}),
        {%- endfor -%}
    ];

    pub fn new(version: Version) -> std::result::Result<Self, Error> {
        if Self::SUPPORTED_VERSIONS.contains(&version) {
            Ok(Self {
                {%- for version in code.referenced_versions -%}
                    {# Separator #}
                    version_is_at_least_{{ version | replace(from=".", to="_") }}: Version::new({{ version | split(pat=".") | join(sep=", ") }}) <= version,
                {%- endfor -%}
                version,
            })
        } else {
            Err(Error::UnsupportedLanguageVersion(version))
        }
    }

    pub fn version(&self) -> &Version {
        &self.version
    }

    {# Separator #}
    {%- for context in code.scanner_contexts -%}
        {# Separator #}
        #[allow(dead_code)]
        fn {{ context.name | snake_case }}_parse_token_with_trivia(
            &self,
            stream: &mut Stream,
            kind: TokenKind,
        ) -> ParserResult
        {
            let mut children = vec![];

            let restore = stream.position();
            if let ParserResult::Match(r#match) = self.leading_trivia(stream) {
                children.extend(r#match.nodes);
            } else {
                stream.set_position(restore);
            }

            let start = stream.position();
            if self.{{ context.name | snake_case }}_next_token(stream) != Some(kind) {
                stream.set_position(restore);
                return ParserResult::no_match(vec![kind]);
            }
            let end = stream.position();
            children.push(cst::Node::token(kind, stream.content(start.utf8..end.utf8)));

            let restore = stream.position();
            if let ParserResult::Match(r#match) = self.trailing_trivia(stream) {
                children.extend(r#match.nodes);
            } else {
                stream.set_position(restore);
            }

            return ParserResult::r#match(children, vec![]);
        }

        #[allow(dead_code)]
        fn {{ context.name | snake_case }}_greedy_parse_token_with_trivia(&self, stream: &mut Stream, terminator: TokenKind) -> ParserResult {
            let mut children = vec![];

            let restore = stream.position();
            if let ParserResult::Match(r#match) = self.leading_trivia(stream) {
                children.extend(r#match.nodes);
            } else {
                stream.set_position(restore);
            }

            let start = stream.position();
            let mut end_scan = stream.position();
            let found = loop {
                match self.{{ context.name | snake_case }}_next_token(stream) {
                    // Greedily scan until we find the terminator, while updating the latest position
                    Some(kind) if kind != terminator => end_scan = stream.position(),
                    // Terminator found, optionally include the skipped tokens
                    Some(terminator) => {
                        if end_scan > start {
                            children.push(cst::Node::error(stream.content(start.utf8..end_scan.utf8), vec![]));
                        }

                        children.push(cst::Node::token(terminator, stream.content(end_scan.utf8..stream.position().utf8)));
                        break true;
                    }

                    None => break false,
                }
            };

            if !found {
                stream.set_position(restore);

                ParserResult::no_match(vec![terminator])
            } else {
                let restore = stream.position();
                if let ParserResult::Match(r#match) = self.trailing_trivia(stream) {
                    children.extend(r#match.nodes);
                } else {
                    stream.set_position(restore);
                }

                // Report the terminator as expected earlier if we skipped some tokens trying to recover
                let skipped_some = end_scan > start;
                ParserResult::r#match(children, if skipped_some { vec![terminator] } else { vec![] })
            }
        }

        #[allow(dead_code)]
        fn {{ context.name | snake_case }}_skip_tokens_until(&self, stream: &mut Stream, expected: TokenKind) -> Option<std::ops::Range<usize>> {
            let start = stream.position();
            let mut end_scan = stream.position();
            loop {
                let restore = stream.position();
                match self.{{ context.name | snake_case }}_next_token(stream) {
                    // Greedily scan until we find the token, while updating the latest position
                    Some(kind) if kind != expected => end_scan = stream.position(),
                    // Include the skipped tokens
                    Some(..) => {
                        stream.set_position(restore);

                        break if end_scan > start { Some(start.utf8..end_scan.utf8) } else { None };
                    }

                    None => {
                        stream.set_position(start);

                        break None;
                    },
                }
            }
        }

        #[allow(dead_code)]
        fn {{ context.name | snake_case }}_parse_token(&self, stream: &mut Stream, kind: TokenKind) -> ParserResult
        {
            let start = stream.position();
            if self.{{ context.name | snake_case }}_next_token(stream) != Some(kind) {
                stream.set_position(start);
                return ParserResult::no_match(vec![kind]);
            }
            let end = stream.position();
            return ParserResult::r#match(
                vec![cst::Node::token(kind, stream.content(start.utf8..end.utf8))],
                vec![],
            );
        }

        #[allow(unused_assignments, unused_parens)]
        pub fn {{ context.name | snake_case }}_next_token(&self, stream: &mut Stream) -> Option<TokenKind> {
            let save = stream.position();
            let mut furthest_position = stream.position();
            let mut longest_token = None;

            if let Some(kind) = {{ context.alpha_literal_scanner }} {
                // Make sure that this is not the start of an identifier
                if !self.identifier_part(stream) {
                    furthest_position = stream.position();
                    longest_token = Some(kind);
                }
            }
            stream.set_position(save);

            if let Some(kind) = {{ context.non_alpha_literal_scanner }} {
                furthest_position = stream.position();
                longest_token = Some(kind);
            }
            stream.set_position(save);

            macro_rules! longest_match {
                ($( { $kind:ident = $function:ident } )*) => {
                    $(
                        if self.$function(stream) && stream.position() > furthest_position {
                            furthest_position = stream.position();
                            longest_token = Some(TokenKind::$kind);
                        }
                        stream.set_position(save);
                    )*
                };
            }

            longest_match! {
            {%- for name in context.compound_scanner_names -%}
                {# Separator #}
                { {{ name }} = {{ name | snake_case }} }
            {%- endfor -%}
                {# Separator #}
            }

            if longest_token.is_some() {
                stream.set_position(furthest_position);
            }

            longest_token
        }
        {# Separator #}
    {%- endfor -%}
    {# Separator #}

    /********************************************
     *         Parser Functions
     ********************************************/
    {# Separator #}

    {%- for function in code.parser_functions -%}
        {# Separator #}
        #[allow(unused_assignments, unused_parens)]
        pub fn {{ function.0 | snake_case }}(&self, stream: &mut Stream) -> ParserResult { {{ function.1 }} }
        {# Separator #}
    {%- endfor -%}
    {# Separator #}

    /********************************************
     *         Scanner Functions
     ********************************************/

    {# Separator #}

    {%- for function in code.scanner_functions -%}
        {# Separator #}
        #[allow(unused_assignments, unused_parens)]
        fn {{ function.0 | snake_case }}(&self, stream: &mut Stream) -> bool { {{ function.1 }} }
        {# Separator #}
    {%- endfor -%}
    {# Separator #}

    pub fn parse(&self, production_kind: ProductionKind, input: &str) -> ParseOutput {
        match production_kind {
            {%- for function in code.parser_functions -%}
                ProductionKind::{{ function.0 }} => Self::{{ function.0 | snake_case }}.parse(self, input),
            {%- endfor -%}
        }
    }
}

#[cfg( feature = "slang_napi_interfaces" )]
#[napi(namespace = "language")]
impl Language {

    #[napi(constructor)]
    pub fn new_napi(version: String) -> std::result::Result<Self, napi::Error> {
        let version = Version::parse(&version).map_err(|_| Error::InvalidSemanticVersion(version))?;
        Self::new(version).map_err(|e| e.into())
    }

    #[napi(getter, js_name = "version")]
    pub fn version_napi(&self) -> String {
        self.version.to_string()
    }

    #[napi(js_name = "supportedVersions")]
    pub fn supported_versions_napi() -> Vec<String> {
        return Self::SUPPORTED_VERSIONS.iter().map(|v| v.to_string()).collect();
    }

    #[napi(js_name = "parse", ts_return_type = "ParseOutput")]
    pub fn parse_napi(&self, production_kind: ProductionKind, input: String) -> NAPIParseOutput {
        self.parse(production_kind, input.as_str()).into()
    }

}
